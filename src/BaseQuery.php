<?php /** @noinspection PhpUnused */


declare( strict_types = 1 );


namespace JDWX\DNSQuery;


use JDWX\DNSQuery\Data\QR;
use JDWX\DNSQuery\Data\ReturnCode;
use JDWX\DNSQuery\Exceptions\Exception;
use JDWX\DNSQuery\Network\Socket;
use JDWX\DNSQuery\Network\TCPTransport;
use JDWX\DNSQuery\Network\TransportManager;
use JDWX\DNSQuery\Network\UdpTransport;
use JDWX\DNSQuery\Packet\RequestPacket;
use JDWX\DNSQuery\Packet\ResponsePacket;
use JDWX\DNSQuery\RR\RR;
use JDWX\DNSQuery\RR\SIG;
use JDWX\DNSQuery\RR\TSIG;


/**
 * DNS Library for handling lookups and updates.
 *
 * Copyright (c) 2020, Mike Pultz <mike@mikepultz.com>. All rights reserved.
 *
 * See LICENSE for more details.
 *
 */


/**
 * This is the base class for the Resolver, Updater and Notifier classes.
 *
 */
class BaseQuery {


    /** @const The default path to a resolv.conf file. */
    public const string RESOLV_CONF = '/etc/resolv.conf';

    /** @var null|TSIG|SIG the TSIG or SIG RR object for authentication */
    protected TSIG|SIG|null $authSignature = null;

    /** @var int DNS port to use (53) */
    protected int $dnsPort = 53;

    /** @var bool If set, set the DO flag to 1 for DNSSEC requests */
    protected bool $dnssec = false;

    /** @var bool If set, set the AD flag in DNSSEC requests. */
    protected bool $dnssecADFlag = false;

    /** @var bool If set, set the CD flag in DNSSEC requests. */
    protected bool $dnssecCDFlag = false;

    /** @var int The EDNS(0) UDP payload size to use when making DNSSEC requests */
    protected int $dnssecPayloadSize = 4000;

    /** @var string Default domain for names that aren't fully qualified */
    protected string $domain = '';

    /** @var ?Exception Last exception that was generated */
    protected ?Exception $lastException = null;

    /** @var Exception[] List of exceptions generated by name server */
    protected array $lastExceptionList = [];

    /** @var ?string The IPv4 or IPv6 address to use for local sockets */
    protected ?string $localAddress = null;

    /** @var int The port to use for local sockets (0 = selected by OS) */
    protected int $localPort = 0;

    /** @var bool Randomize the list of name servers. */
    protected bool $nsRandom = false;

    /** @var string[] Not actually used right now */
    protected array $searchList = [];

    /** @var int timeout value for socket connections (in seconds) */
    protected int $timeout = 5;

    /** @var TransportManager Support network socket reuse */
    protected TransportManager $transportManager;

    /** @var bool Use any options found in a resolv.conf file
     *
     * if this is set, then certain values from the resolv.conf file will override
     * local settings. This is disabled by default to remain backwards compatible.
     */
    protected bool $useResolvOptions = false;

    /** @var bool Use TCP only (true/false) */
    protected bool $useTCP = false;

    /** @var string[] Name server list specified as IPv4 or IPv6 addresses */
    private array $nameServers = [];


    /**
     * Constructor - base constructor for the Notifier, Resolver and Updater
     * @param list<string>|string|null $i_nameServers a list of IP addresses for name servers
     */
    public function __construct( array|string|null $i_nameServers = null, ?string $i_resolvConf = null ) {
        if ( ! is_null( $i_nameServers ) && ! is_null( $i_resolvConf ) ) {
            throw new Exception( 'cannot specify both name servers and resolv.conf file' );
        }
        if ( is_string( $i_resolvConf ) ) {
            $this->useResolvConf( $i_resolvConf );
        }
        if ( is_string( $i_nameServers ) ) {
            $this->setNameServer( $i_nameServers );
        } elseif ( is_array( $i_nameServers ) ) {
            $this->setNameServers( $i_nameServers );
        }
        $this->transportManager = new TransportManager( $this->localAddress, $this->localPort, $this->timeout );
    }


    /**
     * formats the given IPv6 address as a fully expanded IPv6 address
     *
     * @param string $i_address the IPv6 address to expand
     *
     * @return string the fully expanded IPv6 address
     */
    public static function expandIPv6( string $i_address ) : string {
        $hex = unpack( 'H*hex', inet_pton( $i_address ) );

        return substr( preg_replace( '/([A-f\d]{4})/', '$1:', $hex[ 'hex' ] ), 0, -1 );
    }


    /**
     * PHP doesn't support unsigned integers, but many of the RRs return
     * unsigned values (like SOA), so there is the possibility that the
     * value will overrun on 32bit systems, and you'll end up with a
     * negative value.
     *
     * 64bit systems are not affected, as their PHP_INT_MAX value should
     * be 64bit (ie 9223372036854775807)
     *
     * This function returns a negative integer value, as a string, with
     * the correct unsigned value.
     *
     * @param int $i_int the unsigned integer value to check
     *
     * @return string returns the unsigned value as a string.
     */
    public static function expandUint32( int $i_int ) : string {
        if ( ( $i_int < 0 ) && ( PHP_INT_MAX == 2147483647 ) ) {
            return sprintf( '%u', $i_int );
        } else {
            return (string) $i_int;
        }
    }


    /**
     * returns true/false if the given address is a valid IPv4 address
     *
     * @param string $i_address the IPv4 address to check
     *
     * @return bool returns true/false if the address is IPv4 address
     */
    public static function isIPv4( string $i_address ) : bool {
        return ! ! filter_var( $i_address, FILTER_VALIDATE_IP, FILTER_FLAG_IPV4 );
    }


    /**
     * returns true/false if the given address is a valid IPv6 address
     *
     * @param string $i_address the IPv6 address to check
     *
     * @return bool returns true/false if the address is IPv6 address
     */
    public static function isIPv6( string $i_address ) : bool {
        return ! ! filter_var( $i_address, FILTER_VALIDATE_IP, FILTER_FLAG_IPV6 );
    }


    /**
     * give users access to close all open sockets on the resolver object; resetting each
     * array, calls the destructor on the Socket object, which calls the close()
     * method on each object.
     *
     * @return void
     */
    public function closeSockets() : void {
        $this->transportManager->flush();
    }


    /**
     * Gets the currently-configured name servers or loads them from the default resolv.conf
     * if none are specified.
     *
     * @return string[] A list of IPv4 or IPv6 addresses of the configured nameservers.
     * @throws Exception
     */
    public function getNameServers() : array {

        if ( empty( $this->nameServers ) ) {
            $this->useResolvConf();
        }

        $nameServers = array_merge( [], $this->nameServers );

        # Randomize the name server list if it's asked for.
        if ( $this->nsRandom ) {
            shuffle( $nameServers );
        }

        return $nameServers;
    }


    /**
     * Set the DNS server port to use.  (Default is 53 for both TCP and UDP DNS.)
     *
     * @param int $i_dnsPort
     * @return static
     */
    public function setDNSPort( int $i_dnsPort = 53 ) : static {
        $this->dnsPort = $i_dnsPort;
        return $this;
    }


    /**
     * Request DNSSEC values, by setting the DO flag to 1; this actually makes
     * the resolver add an OPT RR to the additional section, and sets the DO flag
     * in this RR to 1
     *
     * @param bool $i_dnssec Whether to use DNSSEC.
     * @return static
     */
    public function setDNSSEC( bool $i_dnssec = true ) : static {
        $this->dnssec = $i_dnssec;
        return $this;
    }


    /**
     * set the DNSSEC AD (Authentic Data) bit on/off; the AD bit on the request
     * side was previously undefined, and resolvers we instructed to always clear
     * the AD bit when sending a request.
     *
     * RFC6840 section 5.7 defines setting the AD bit in the query as a signal to
     * the server that it wants the value of the AD bit, without needed to request
     * all the DNSSEC data via the DO bit.
     *
     * @param bool $i_dnssecADFlag
     * @return static Fluent setter
     */
    public function setDNSSECADFlag( bool $i_dnssecADFlag = true ) : static {
        $this->dnssecADFlag = $i_dnssecADFlag;
        return $this;
    }


    /**
     * set the DNSSEC CD (Checking Disabled) bit on/off; turning this off means
     * that the DNS resolver will perform its own signature validation so the DNS
     * servers simply pass through all the details.
     *
     * @param bool $i_dnssecCDFlag
     * @return static Fluent setter
     */
    public function setDNSSECCDFlag( bool $i_dnssecCDFlag = true ) : static {
        $this->dnssecCDFlag = $i_dnssecCDFlag;
        return $this;
    }


    /**
     * the EDNS(0) UDP payload size to use when making DNSSEC requests
     * see RFC 4035 section 4.1 - EDNS Support.
     *
     * there are some different ideas on the suggested size to support; but it seems to
     * be "at least" 1220 bytes, but SHOULD support 4000 bytes.  If this is not
     * set, the default is 4000 bytes.
     *
     * @param int $i_dnssecPayloadSize Payload size in bytes.
     * @return static Fluent setter
     */
    public function setDNSSECPayloadSize( int $i_dnssecPayloadSize ) : static {
        $this->dnssecPayloadSize = $i_dnssecPayloadSize;
        return $this;
    }


    /**
     * Set the local IP address to use.  (Default is empty, which means to use the
     * default local IP address.)
     *
     * @param string $i_localHost
     * @return static Fluent setter
     */
    public function setLocalAddress( string $i_localHost = '' ) : static {
        $this->localAddress = $i_localHost;
        return $this;
    }


    /**
     * Set the local port to use.  (Default is 0, which means to use a
     * local port selected by the OS.)
     *
     * @param int $i_localPort Local port value to use
     * @return static          Fluent setter
     */
    public function setLocalPort( int $i_localPort = 0 ) : static {
        $this->localPort = $i_localPort;
        return $this;
    }


    /**
     * Shortcut to set a single name server.
     *
     * @param string $i_nameServer IPv4 or IPv6 address of the desired name server
     * @throws Exception
     */
    public function setNameServer( string $i_nameServer ) : static {
        return $this->setNameServers( [ $i_nameServer ] );
    }


    /**
     * Sets the name servers to be used, specified as IPv4 or IPv6 addresses.
     *
     * @param string[] $i_nameServers a list of IPv4 or IPv6 addresses
     *
     * @throws Exception
     */
    public function setNameServers( array $i_nameServers ) : static {

        # Collect valid IP addresses in a temporary list.
        $ipAddresses = [];

        foreach ( $i_nameServers as $value ) {
            if ( self::isIPv4( $value ) || self::isIPv6( $value ) ) {
                $ipAddresses[] = $value;
            } else {
                throw new Exception(
                    'invalid nameserver entry: ' . $value,
                    Lookups::E_NS_INVALID_ENTRY
                );
            }
        }

        $ipAddresses = array_unique( $ipAddresses );
        if ( empty( $ipAddresses ) ) {
            throw new Exception(
                'empty name servers list; you must provide a list of name servers',
                Lookups::E_NS_INVALID_ENTRY
            );
        }

        # Only replace the nameservers list if no exception is thrown.
        $this->nameServers = $ipAddresses;
        return $this;
    }


    /**
     * Set whether to randomize the name server list.  (Default is false.)
     *
     * @param bool $i_randomize True to randomize the name server list, false to not randomize
     * @return static            Fluent setter
     */
    public function setRandomizeNameServers( bool $i_randomize = true ) : static {
        $this->nsRandom = $i_randomize;
        return $this;
    }


    /**
     * Set the timeout value to use for socket connections.  (Default is 5 seconds.)
     *
     * @param int $i_timeout Timeout value in seconds.
     * @return static         Fluent setter
     */
    public function setTimeout( int $i_timeout ) : static {
        $this->timeout = $i_timeout;
        return $this;
    }


    /**
     * Set whether to use options found in resolv.conf if one is parsed.
     *
     * Note that this will not affect the use of the resolv.conf file if it is loaded from the
     * constructor.  So if you want this option, set it and then manually call useResolvConf().
     *
     * @param bool $i_useResolvOptions Whether to use options found in resolv.conf
     * @return static                  Fluent setter
     */
    public function setUseResolvOptions( bool $i_useResolvOptions ) : static {
        $this->useResolvOptions = $i_useResolvOptions;
        return $this;
    }


    /** Default to using TCP for requests.  (TCP will always be used for large
     * requests or AXFR requests.)
     *
     * @param bool $i_useTCP Whether to use TCP for requests by default.
     * @return static           Fluent setter
     */
    public function setUseTCP( bool $i_useTCP = true ) : static {
        $this->useTCP = $i_useTCP;
        return $this;
    }


    /**
     * Add a SIG RR object for authentication.
     *
     * @param SIG|string $i_filename a signature or the name of a file to load the signature from.
     *
     * @return void
     * @throws Exception
     * @since  function available since release 1.1.0
     */
    public function signSIG0( SIG|string $i_filename ) : void {

        # Check for OpenSSL
        if ( extension_loaded( 'openssl' ) === false ) {

            throw new Exception(
                'the OpenSSL extension is required to use SIG(0).',
                Lookups::E_OPENSSL_UNAVAIL
            );
        }

        # If the SIG was pre-created, then use it as-is.
        if ( $i_filename instanceof SIG ) {
            $this->authSignature = $i_filename;

        } else {

            # Otherwise, it's filename which needs to be parsed and processed.
            $private = new PrivateKey( $i_filename );

            # Create a new SIG object.
            $this->authSignature = new SIG();

            # Reset some values.
            $this->authSignature->name = $private->signName;
            $this->authSignature->ttl = 0;
            $this->authSignature->class = 'ANY';

            # These values are pulled from the private key.
            $this->authSignature->algorithm = $private->algorithm;
            $this->authSignature->keytag = $private->keytag;
            $this->authSignature->signName = $private->signName;

            # These values are hard-coded for SIG0.
            $this->authSignature->typeCovered = 'SIG0';
            $this->authSignature->labels = 0;
            $this->authSignature->origTTL = 0;

            # Generate the dates.
            $time = time();

            $this->authSignature->sigInception = gmdate( 'YmdHis', $time );
            $this->authSignature->sigExpiration = gmdate( 'YmdHis', $time + 500 );

            # Store the private key in the SIG object for later.
            $this->authSignature->privateKey = $private;
        }

        # Only RSA algorithms are supported for SIG(0).
        switch ( $this->authSignature->algorithm ) {
            case Lookups::DNSSEC_ALGORITHM_RSAMD5:
            case Lookups::DNSSEC_ALGORITHM_RSASHA1:
            case Lookups::DNSSEC_ALGORITHM_RSASHA256:
            case Lookups::DNSSEC_ALGORITHM_RSASHA512:
            case Lookups::DNSSEC_ALGORITHM_DSA:
                break;
            default:
                throw new Exception(
                    'only asymmetric algorithms work with SIG(0)!',
                    Lookups::E_OPENSSL_INV_ALGO
                );
        }

    }


    /**
     * Add a TSIG RR object for authentication
     *
     * @param TSIG|string $i_keyName Key name to use for the TSIG RR
     * @param string $i_signature Key to sign the request.
     * @param string $i_algorithm Algorithm to use
     *
     * @return void
     *
     * @throws Exception
     * @since  function available since release 1.1.0
     *
     */
    public function signTSIG(
        TSIG|string $i_keyName, string $i_signature = '', string $i_algorithm = TSIG::HMAC_MD5
    ) : void {

        # If the TSIG was pre-created and passed in, then we can just use
        # it as provided.
        if ( $i_keyName instanceof TSIG ) {
            $this->authSignature = $i_keyName;
            return;
        }

        # Otherwise create the TSIG RR, but don't add it just yet; TSIG needs
        # to be added as the last additional entry so we'll add it just
        # before we send.
        $xx = RR::fromString(
            strtolower( trim( $i_keyName ) ) .
            ' TSIG ' . $i_signature
        );
        assert( $xx instanceof TSIG );
        $this->authSignature = $xx;

        # Set the algorithm to use.
        $this->authSignature->algorithm = $i_algorithm;
    }


    /**
     * sets the name servers to be used, specified as IPv4 or IPv6 addresses
     *
     * @param ?string $i_resolvConf Filename to parse in the resolv.conf format or null
     *                              to use the default resolv.conf file
     *
     * @return static               Fluent setter
     * @throws Exception
     */
    public function useResolvConf( ?string $i_resolvConf = null ) : static {

        # Temporary list of name servers; do it this way rather than just
        # resetting the local nameservers value, just in case an exception
        # is thrown here; this way we might avoid ending up with an empty
        # list of nameservers.
        $ns = [];

        $resolvConf = $i_resolvConf ?? self::RESOLV_CONF;

        # Check to see if the file is readable.
        if ( is_readable( $resolvConf ) !== true ) {
            throw new Exception(
                'resolver file file provided is not readable: ' . $resolvConf,
                Lookups::E_NS_INVALID_FILE
            );
        }

        $data = file_get_contents( $resolvConf );
        if ( $data === false ) {
            throw new Exception(
                'failed to read contents of file: ' . $resolvConf,
                Lookups::E_NS_INVALID_FILE
            );
        }

        $lines = explode( "\n", $data );

        foreach ( $lines as $line ) {

            $line = trim( $line );

            # Ignore empty lines, and lines that are commented out.
            if ( ( strlen( $line ) == 0 )
                || ( $line[ 0 ] == '#' )
                || ( $line[ 0 ] == ';' )
            ) {
                continue;
            }

            # Ignore lines with no spaces in them.
            if ( ! str_contains( $line, ' ' ) ) {
                continue;
            }

            [ $key, $value ] = preg_split( '/\s+/', $line, 2 );

            $key = trim( strtolower( $key ) );
            $value = trim( strtolower( $value ) );

            switch ( $key ) {
                case 'nameserver':

                    # Nameserver can be a IPv4 or IPv6 address.
                    if ( self::isIPv4( $value )
                        || self::isIPv6( $value )
                    ) {
                        $ns[] = $value;
                    } else {
                        throw new Exception(
                            'invalid nameserver entry: ' . $value,
                            Lookups::E_NS_INVALID_ENTRY
                        );
                    }
                    break;

                case 'domain':
                    $this->domain = $value;
                    break;

                case 'search':
                    $this->searchList = preg_split( '/\s+/', $value );
                    break;

                case 'options':
                    $this->parseOptions( $value );
                    break;

            }
        }

        # If we don't have a domain, but we have a search list, then
        # take the first entry on the search list as the domain.
        if ( ( strlen( $this->domain ) == 0 )
            && ( count( $this->searchList ) > 0 )
        ) {
            $this->domain = $this->searchList[ 0 ];
        }

        $this->setNameServers( $ns );

        return $this;

    }


    /**
     * Sends a RequestPacket
     *
     * @param RequestPacket $i_request Packet object to send
     * @param bool $i_useTCP True to skip straight to TCP, false to try UDP first.
     *
     * @return ResponsePacket
     * @throws Exception
     */
    protected function sendPacket( RequestPacket $i_request, bool $i_useTCP ) : ResponsePacket {

        # Get the data from the packet
        $data = $i_request->get();
        if ( strlen( $data ) < Lookups::DNS_HEADER_SIZE ) {

            throw new Exception(
                'invalid or empty packet for sending!',
                Lookups::E_PACKET_INVALID,
                null,
                $i_request
            );
        }

        $nameServers = $this->getNameServers();

        # Loop so we can handle server errors

        while ( 1 ) {

            # Grab the next DNS server
            $ns = current( $nameServers );
            next( $nameServers );

            if ( $ns === false ) {

                if ( ! is_null( $this->lastException ) ) {
                    throw $this->lastException;
                } else {

                    throw new Exception(
                        'every name server provided has failed',
                        Lookups::E_NS_FAILED
                    );
                }
            }

            # If the use TCP flag (force TCP) is set, or the packet is bigger than our
            # max allowed UDP size, which is either 512, or if this is DNSSEC request,
            # then whatever the configured dnssec_payload_size is.
            $maxUDPSize = Lookups::DNS_MAX_UDP_SIZE;
            if ( $this->dnssec ) {
                $maxUDPSize = $this->dnssecPayloadSize;
            }

            if ( $i_useTCP || ( strlen( $data ) > $maxUDPSize ) ) {

                try {
                    $response = $this->sendTCPRequest( $ns, $data, $i_request->question[ 0 ]->qType == 'AXFR' );
                } catch ( Exception $ex ) {

                    $this->lastException = $ex;
                    $this->lastExceptionList[ $ns ] = $ex;

                    continue;
                }

                # Otherwise, send it using UDP.
            } else {

                try {
                    $response = $this->sendUDPRequest( $ns, $data );

                    # Check the packet header for a truncated bit; if it was truncated,
                    # then re-send the request as TCP.
                    if ( $response->header->tc == 1 ) {

                        $response = $this->sendTCPRequest( $ns, $data );
                    }

                } catch ( Exception $ex ) {

                    $this->lastException = $ex;
                    $this->lastExceptionList[ $ns ] = $ex;

                    continue;
                }
            }

            # Make sure header IDs match between the request and response.
            if ( $i_request->header->id != $response->header->id ) {

                $this->lastException = new Exception(

                    'invalid header: the request and response id do not match.',
                    Lookups::E_HEADER_INVALID,
                    null,
                    $i_request,
                    $response
                );

                $this->lastExceptionList[ $ns ] = $this->lastException;
                continue;
            }

            # Make sure the response is actually a response. (0 = query, 1 = response)
            if ( $response->header->qr !== QR::RESPONSE->value ) {

                $this->lastException = new Exception(

                    'invalid header: the response provided is not a response packet.',
                    Lookups::E_HEADER_INVALID,
                    null,
                    $i_request,
                    $response
                );

                $this->lastExceptionList[ $ns ] = $this->lastException;
                continue;
            }

            # Make sure the response code in the header is ok.
            if ( $response->header->rCode !== ReturnCode::NOERROR->value ) {

                $this->lastException = new Exception(

                    "DNS request to {$ns} failed: " .
                    ReturnCode::from( $response->header->rCode )->decode(),
                    $response->header->rCode,
                    null,
                    $i_request,
                    $response
                );

                $this->lastExceptionList[ $ns ] = $this->lastException;
                continue;
            }

            break;
        }

        return $response;
    }


    /**
     * parses the options line from a resolv.conf file; we don't support all the options
     * yet, and using them is optional.
     *
     * @param string $i_options The "options" string from the resolv.conf file.
     *
     * @return void
     */
    private function parseOptions( string $i_options ) : void {

        # If overrides are disabled (the default), or the options list is empty for some
        # reason, then we don't need to do any of this work.
        if ( ! $this->useResolvOptions || ( strlen( $i_options ) == 0 ) ) {
            return;
        }

        $options = preg_split( '/\s+/', strtolower( $i_options ) );

        foreach ( $options as $option ) {

            # Override the timeout value from the resolv.conf file.
            if ( ( strncmp( $option, 'timeout', 7 ) == 0 ) && ( str_contains( $option, ':' ) ) ) {

                $val = (int) explode( ':', $option )[ 1 ];

                if ( ( $val > 0 ) && ( $val <= 30 ) ) {
                    $this->timeout = $val;
                }

            } elseif ( strncmp( $option, 'rotate', 6 ) == 0 ) {
                # The rotate option just enables the ns_random option.
                $this->nsRandom = true;
            }
        }

    }


    /**
     * sends a DNS request using TCP
     *
     * @param string $i_ns Name server to use for the request
     * @param string $i_data Raw DNS packet data
     * @param bool $i_axfr Whether this is a zone transfer request
     *
     * @return ResponsePacket the response object
     * @throws Exception
     */
    private function sendTCPRequest( string $i_ns, string $i_data, bool $i_axfr = false ) : ResponsePacket {
        $tcp = $this->transportManager->acquire( Socket::SOCK_STREAM, $i_ns, $this->dnsPort );
        assert( $tcp instanceof TCPTransport );
        $tcp->sendData( $i_data );

        if ( $i_axfr ) {
            $rsp = $tcp->receiveAXFR();
        } else {
            $rsp = $tcp->receiveResponse();
        }
        $this->transportManager->release( $tcp );
        return $rsp;
    }


    /**
     * sends a DNS request using UDP
     *
     * @param string $i_ns the name server to use for the request
     * @param string $i_data the raw DNS packet data
     *
     * @return ResponsePacket the response object
     * @throws Exception
     */
    private function sendUDPRequest( string $i_ns, string $i_data ) : ResponsePacket {
        $udp = $this->transportManager->acquire( Socket::SOCK_DGRAM, $i_ns, $this->dnsPort );
        # TODO: We should be using $udp->sendRequest() instead.
        assert( $udp instanceof UdpTransport );
        $udp->sendData( $i_data );
        $rsp = $udp->receiveResponse();
        $this->transportManager->release( $udp );
        return $rsp;
    }


}

