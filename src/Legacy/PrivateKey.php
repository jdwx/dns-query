<?php


declare( strict_types = 1 );


namespace JDWX\DNSQuery\Legacy;


use JDWX\DNSQuery\Exceptions\Exception;
use OpenSSLAsymmetricKey;


/**
 * DNS Library for handling lookups and updates.
 *
 * Copyright (c) 2020, Mike Pultz <mike@mikepultz.com>. All rights reserved.
 *
 * See LICENSE for more details.
 *
 * @author    Mike Pultz <mike@mikepultz.com>
 * @copyright 2020 Mike Pultz <mike@mikepultz.com>
 * @license   http://www.opensource.org/licenses/bsd-license.php  BSD License
 * @link      https://netdns2.com/
 * @since     File available since Release 1.1.0
 *
 */


/**
 * SSL Private Key container class
 *
 */
class PrivateKey {


    /** @var string Filename that was loaded; stored for reference */
    public string $filename;

    /** @var int Key tag for the signature */
    public int $keytag;

    /** @var string Sign name for the signature */
    public string $signName;

    /** @var int Algorithm ID used for the signature */
    public int $algorithm;

    /** @var string Key format of the signature */
    public string $keyFormat;

    /** @var bool|OpenSSLAsymmetricKey OpenSSL Private Key object */
    public bool|OpenSSLAsymmetricKey $instance = false;

    /** @var string DSA prime */
    public string $prime;

    /** @var string DSA subprime */
    public string $subprime;

    /** @var string DSA base */
    public string $base;

    /** @var string DSA private value */
    public string $privateValue;

    /** @var string DSA public value */
    public string $publicValue;

    /** @var string RSA Modulus */
    private string $modulus;

    /** @var string RSA Public Exponent */
    private string $publicExponent;

    /** @var string RSA Private Exponent */
    private string $privateExponent;

    /** @var string RSA Prime 1 */
    private string $prime1;

    /** @var string RSA Prime 2 */
    private string $prime2;

    /** @var string RSA Exponent 1 */
    private string $exponent1;

    /** @var string RSA Exponent 2 */
    private string $exponent2;

    /** @var string RSA Coefficient */
    private string $coefficient;


    /**
     * Constructor - base constructor the private key container class
     *
     * @param ?string $i_keyPath Path to a private key file to load and parse, or null to defer loading
     *
     * @throws Exception If a key file was specified and could not be loaded
     */
    public function __construct( ?string $i_keyPath = null ) {
        if ( is_string( $i_keyPath ) ) {
            $this->parseFile( $i_keyPath );
        }
    }


    /**
     * Parse a private key file generated by dnssec-keygen
     *
     * @param string $i_keyPath path to a private-key file to load and parse
     *
     * @return void
     * @throws Exception If OpenSSL isn't working or the file could not be loaded
     */
    public function parseFile( string $i_keyPath ) : void {

        # Check for OpenSSL.
        if ( extension_loaded( 'openssl' ) === false ) {
            throw new Exception(
                'the OpenSSL extension is required to use parse private key.',
                Lookups::E_OPENSSL_UNAVAIL
            );
        }

        # Check to make sure the file exists.
        if ( ! is_readable( $i_keyPath ) ) {
            throw new Exception(
                'invalid private key file: ' . $i_keyPath,
                Lookups::E_OPENSSL_INV_PKEY
            );
        }

        # Get the base filename, and parse it for the local value.
        $keyName = basename( $i_keyPath );
        if ( strlen( $keyName ) == 0 ) {
            throw new Exception(
                'failed to get basename() for: ' . $i_keyPath,
                Lookups::E_OPENSSL_INV_PKEY
            );
        }

        # Parse the key name.
        if ( ! preg_match( '/K(.*)\.\+(\d{3})\+(\d*)\.private/', $keyName, $matches ) ) {
            throw new Exception(
                'file ' . $keyName . ' does not look like a private key file!',
                Lookups::E_OPENSSL_INV_PKEY
            );
        }

        $this->signName = $matches[ 1 ];
        $this->algorithm = (int) $matches[ 2 ];
        $this->keytag = (int) $matches[ 3 ];

        # Read all the data from the file.
        $data = file( $i_keyPath, FILE_IGNORE_NEW_LINES | FILE_SKIP_EMPTY_LINES );
        if ( count( $data ) == 0 ) {

            throw new Exception(
                'file ' . $keyName . ' is empty!',
                Lookups::E_OPENSSL_INV_PKEY
            );
        }

        foreach ( $data as $line ) {

            [ $key, $value ] = explode( ':', $line );

            $key = trim( $key );
            $value = trim( $value );

            switch ( strtolower( $key ) ) {

                case 'private-key-format':
                    $this->keyFormat = $value;
                    break;

                case 'algorithm':
                    if ( $this->algorithm != $value ) {
                        throw new Exception(
                            'Algorithm mis-match! filename is ' . $this->algorithm .
                            ', contents say ' . $value,
                            Lookups::E_OPENSSL_INV_ALGO
                        );
                    }
                    break;

                # RSA
                case 'modulus':
                    $this->modulus = $value;
                    break;

                /** @noinspection SpellCheckingInspection */
                case 'publicexponent':
                    $this->publicExponent = $value;
                    break;

                /** @noinspection SpellCheckingInspection */
                case 'privateexponent':
                    $this->privateExponent = $value;
                    break;

                case 'prime1':
                    $this->prime1 = $value;
                    break;

                case 'prime2':
                    $this->prime2 = $value;
                    break;

                case 'exponent1':
                    $this->exponent1 = $value;
                    break;

                case 'exponent2':
                    $this->exponent2 = $value;
                    break;

                case 'coefficient':
                    $this->coefficient = $value;
                    break;

                # DSA - this won't work in PHP until the OpenSSL extension is better
                case 'prime(p)':
                    $this->prime = $value;
                    break;

                case 'subprime(q)':
                    $this->subprime = $value;
                    break;

                case 'base(g)':
                    $this->base = $value;
                    break;

                case 'private_value(x)':
                    $this->privateValue = $value;
                    break;

                case 'public_value(y)':
                    $this->publicValue = $value;
                    break;

                default:
                    throw new Exception(
                        'unknown private key data: ' . $key . ': ' . $value,
                        Lookups::E_OPENSSL_INV_PKEY
                    );
            }
        }

        # Generate the private key.
        /** @noinspection SpellCheckingInspection */
        $args = match ( $this->algorithm ) {
            Lookups::DNSSEC_ALGORITHM_RSAMD5,
            Lookups::DNSSEC_ALGORITHM_RSASHA1,
            Lookups::DNSSEC_ALGORITHM_RSASHA256,
            Lookups::DNSSEC_ALGORITHM_RSASHA512 => [

                'rsa' => [

                    'n' => base64_decode( $this->modulus ),
                    'e' => base64_decode( $this->publicExponent ),
                    'd' => base64_decode( $this->privateExponent ),
                    'p' => base64_decode( $this->prime1 ),
                    'q' => base64_decode( $this->prime2 ),
                    'dmp1' => base64_decode( $this->exponent1 ),
                    'dmq1' => base64_decode( $this->exponent2 ),
                    'iqmp' => base64_decode( $this->coefficient ),
                ],
            ],
            Lookups::DNSSEC_ALGORITHM_DSA => [

                'dsa' => [

                    'p' => base64_decode( $this->prime ),
                    'q' => base64_decode( $this->subprime ),
                    'g' => base64_decode( $this->base ),
                    'priv_key' => base64_decode( $this->privateValue ),
                    'pub_key' => base64_decode( $this->publicValue ),
                ],
            ],
            default => throw new Exception(
                'we only currently support RSA MD5 and RSA SHA1 encryption.',
                Lookups::E_OPENSSL_INV_PKEY
            ),
        };

        # Generate and store the key.
        $this->instance = openssl_pkey_new( $args );
        if ( $this->instance === false ) {
            throw new Exception(
                openssl_error_string(),
                Lookups::E_OPENSSL_ERROR
            );
        }

        # Store the filename in case we need it for something.
        $this->filename = $i_keyPath;

    }


}
